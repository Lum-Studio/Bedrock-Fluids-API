# Bedrock Fluids API

This document outlines the architecture and components of the Bedrock Fluids API, a system designed to simulate custom fluid dynamics in Minecraft Bedrock Edition by leveraging its existing scripting and resource pack capabilities.

## Introduction

Minecraft Bedrock Edition does not offer a built-in API for creating custom fluids. This project provides a workaround by combining Python-based asset generation, a custom block component, and a sophisticated scripting backend to mimic realistic fluid behavior, including flow, depth changes, and interaction with the environment.

## Core Concepts

The API is built on three main pillars:

1.  **State-Driven Geometry**: The visual appearance of the fluid is determined by the block's states, primarily `fluid_state` (representing depth) and `slope` (representing flow direction). Each combination of these states corresponds to a unique block permutation.

2.  **Dynamic Geometry Generation**: Python scripts are used to pre-generate the JSON files that define the fluid's geometry and block permutations. This approach allows for complex visual effects without requiring real-time model creation in-game.

3.  **Scripting Core**: A set of JavaScript files running in the behavior pack manages the fluid's logic. This includes detecting neighbor block changes, updating fluid states, and handling interactions with players and the environment.

## Key Components

### 1. Python Generators

-   **`fluids_geometry.py`**: Generates `fluid_geometry.json`, which contains the definitions for all the possible 3D models (geometries) of the fluid. It creates different models for various fluid depths and flow directions (including cardinal and diagonal slopes).
-   **`perm_generator_sen.py`**: Generates `fluid_block_permutations.json`, which defines the permutations that link specific block states (like `fluid_state` and `slope`) to the corresponding geometry from `fluid_geometry.json`.

### 2. Behavior Pack (`BP fluids`)

-   **`blocks/custom_fluid.json`**: The core block definition file. It defines the `lumstudio:oil` block, its possible states (`fluid_state`, `slope`, `lumstudio:depth`, etc.), and attaches the custom script component `lumstudio:fluidBehavior`.
-   **`scripts/SenFluids.js`**: This script registers and implements the `lumstudio:fluidBehavior` custom component. This component is the brain of the fluid, reacting to game events like `onPlace`, `onTick`, and `onPlayerDestroy`. It's responsible for updating the fluid's state based on its surroundings.
-   **`scripts/NeighborChanged.js`**: A critical and innovative part of the API. Since Bedrock has no native `onNeighborChanged` event, this script simulates it. It monitors the blocks adjacent to a fluid block and triggers updates when they change. This is achieved through an efficient, cooperative scanning loop that minimizes performance impact.
-   **`scripts/fluids.js`**: This script contains duplicated and sometimes conflicting logic, but its primary intended role is to handle direct player interactions with the fluid, such as placing/taking fluid with a bucket, and applying effects like buoyancy and fog. It also contains the core fluid update logic (`fluidBasic`) and a system for queuing block updates.
-   **`scripts/queue.js`**: Implements the `FluidQueue` class, a system for managing and processing fluid block updates over time. This prevents the game from being overwhelmed by too many simultaneous updates, which is crucial for performance. It processes a limited number of updates per tick from an `optimized` queue and handles high-priority updates in an `instant` queue.

### 3. Resource Pack (`RP fluids`)

-   **`models/`**: This directory would contain the `fluid_geometry.json` generated by the Python script.
-   **`textures/`**: Contains the image files for the fluid's appearance.
-   **`blocks.json`**: A standard resource pack file that maps the `lumstudio:oil` block to its textures and models.

## How it Works: The Fluid Lifecycle

1.  **Placement**: A player places a fluid block (e.g., from a bucket).
2.  **Initialization**: The `onPlace` event in `SenFluids.js` fires. It initializes the block's states (depth, slope, etc.) and registers it with the `NeighborChanged.js` monitor.
3.  **Update Trigger**: The fluid's state needs to be updated in two scenarios:
    -   **Periodic Tick**: The `onTick` event in `SenFluids.js` fires regularly.
    -   **Neighbor Change**: The `NeighborChanged.js` monitor detects a change in an adjacent block (e.g., a block is broken) and triggers an update.
4.  **State Calculation**: When an update is triggered, the `fluidBasic` function (in `fluids.js`) is called via the `FluidQueue`. This function:
    -   Checks the surrounding blocks (above, below, and horizontally).
    -   Determines if the fluid should flow, fall, or be removed.
    -   Calculates the new depth and slope.
5.  **Permutation Update**: The script updates the block's permutation with the newly calculated states.
6.  **Rendering**: The game client sees the new permutation and, based on the rules in `fluid_block_permutations.json`, selects the correct geometry from `fluid_geometry.json` to render, creating the visual effect of flowing fluid.

## How to Use and Extend

To create a new custom fluid:

1.  **Configure Generators**: Modify the Python scripts (`fluids_geometry.py` and `perm_generator_sen.py`) to define the properties of your new fluid (e.g., name, texture paths).
2.  **Generate Assets**: Run the Python scripts to generate the corresponding `fluid_geometry.json` and `fluid_block_permutations.json`.
3.  **Update Resource Pack**:
    -   Add the generated JSON files to your resource pack.
    -   Add the necessary textures for your new fluid.
    -   Update `blocks.json` to define your new fluid block's appearance.
4.  **Update Behavior Pack**:
    -   Create a new block definition file (e.g., `my_new_fluid.json`) in the `blocks` folder.
    -   In this file, define your block and attach the `"lumstudio:fluidBehavior"` custom component.
    -   In `fluids.js`, create a new `FluidQueue` instance for your new fluid type and register it.
5.  **Refine Logic**: If your new fluid has unique behaviors, you may need to modify the logic in `fluids.js` and `SenFluids.js`. Given the duplicated code, a refactor to consolidate the logic into a single, clear system is highly recommended.
