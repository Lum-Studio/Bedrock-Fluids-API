<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Custom Fluid Maker for GitHub Pages</title>
  <!-- Load Libraries from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background: #f3f3f3;
      margin: 0;
      padding: 2rem;
    }
    .container {
      max-width: 600px;
      background: white;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      margin: auto;
    }
    h1 {
      text-align: center;
    }
    label {
      display: block;
      margin-top: 1rem;
    }
    input, select, button {
      width: 100%;
      padding: 0.75rem;
      margin-top: 0.25rem;
      box-sizing: border-box;
    }
    .checkboxes {
      margin-top: 1rem;
    }
    .checkboxes label {
      display: flex;
      align-items: center;
    }
    .checkboxes input {
      width: auto;
      margin-right: 0.5rem;
    }
    button {
      margin-top: 2rem;
      background: #007acc;
      color: white;
      font-size: 1rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    button:hover {
      background: #005fa3;
    }
    button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    .status {
      text-align: center;
      margin-top: 1rem;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Custom Fluid Maker</h1>
    <form id="fluidForm">
      <label for="fluidName">Fluid Name</label>
      <input type="text" id="fluidName" placeholder="e.g. Liquid Bismuth" required />

      <label for="fluidID">Block ID (must include namespace)</label>
      <input type="text" id="fluidID" placeholder="e.g. lumstudio:liquid_bismuth" required pattern="[a-z_]+:[a-z_]+" />

      <label for="texture">Upload Fluid Texture (PNG)</label>
      <input type="file" id="texture" accept="image/png" required />

      <label for="bucketTexture">Upload Bucket Texture (PNG)</label>
      <input type="file" id="bucketTexture" accept="image/png" required />

      <label for="fogColor">Fog Color</label>
      <input type="color" id="fogColor" value="#777777" />

      <label for="buoyancy">Buoyancy</label>
      <input type="number" id="buoyancy" step="0.01" value="0.03" />

      <label for="damage">Damage Per Tick</label>
      <input type="number" id="damage" step="1" value="0" />

      <label for="effect">Status Effect (optional)</label>
      <select id="effect">
        <option value="">None</option>
        <option value="slowness">Slowness</option>
        <option value="poison">Poison</option>
        <option value="blindness">Blindness</option>
        <option value="night_vision">Night Vision</option>
      </select>

      <div class="checkboxes">
        <label><input type="checkbox" id="burnsEntities" /> Burns Entities</label>
        <label><input type="checkbox" id="supportsBoats" checked /> Supports Boats</label>
      </div>

      <button type="submit" id="generateButton">Generate Fluid Pack</button>
      <div class="status" id="statusMessage"></div>
    </form>
  </div>

  <!-- Load the generator logic -->
  <script src="generator.js"></script>
  
  <!-- Main application script -->
  <script>
    // --- Embedded Script Files ---
    const API_JS_CONTENT = JSON.stringify(`import { world, system, BlockPermutation, Block } from "@minecraft/server";
import { BlockUpdate } from "./BlockUpdate.js";
import { Queues } from "./generated/register_fluids.js";

/*========================================================================
  Constants
========================================================================*/

export const AIR = BlockPermutation.resolve("air");
export const DIRECTIONS = [
  { dx: 0, dy: 0, dz: -1, facing: "n" },
  { dx: 1, dy: 0, dz: 0, facing: "e" },
  { dx: 0, dy: 0, dz: 1, facing: "s" },
  { dx: -1, dy: 0, dz: 0, facing: "w" },
];

/*========================================================================
  Utility Functions
========================================================================*/

export function areEqualPermutations(perm1, perm2) {
  if (!perm1 || !perm2) return false;
  const states1 = perm1.getAllStates();
  const states2 = perm2.getAllStates();
  return Object.keys(states1).every(key => states1[key] === states2[key]);
}

export function fluidState(depth) {
  if (depth >= 0.875) return "full";
  if (depth >= 0.75) return "flowing_0";
  if (depth >= 0.625) return "flowing_1";
  if (depth >= 0.5) return "flowing_2";
  if (depth >= 0.375) return "flowing_3";
  if (depth >= 0.25) return "flowing_4";
  if (depth >= 0.125) return "flowing_5";
  return "empty";
}

export function calculateSlope(b) {
  const open = [];
  for (const { dx, dz, facing } of DIRECTIONS) {
    try {
      const neighbor = b.offset({ x: dx, y: 0, z: dz });
      if (neighbor && neighbor.isAir) {
        open.push(facing);
      }
    } catch (e) {
      // Ignore if neighbor is not loaded.
    }
  }
  if (open.length === 0) return "none";
  open.sort();
  if (open.length === 2) {
    const combo = open.join("");
    const diagonals = { "en": "ne", "es": "se", "nw": "nw", "sw": "sw" };
    if (diagonals[combo]) return diagonals[combo];
  }
  return open[0];
}

/*========================================================================
  Core Fluid Logic
========================================================================*/

/**
 * The core update logic for a single fluid block.
 * This function is called by the FluidQueue for each block that needs an update.
 * @param {Block} b The fluid block to update.
 */
function fluidUpdate(b) {
    if (!b || !b.isValid() || !b.permutation) return;

    const fluidBlock = b.permutation;
    const maxSpreadDistance = 7; // This can be configured per fluid type later
    const fluidStates = fluidBlock.getAllStates();
    const depth = fluidStates["lumstudio:depth"];
    const isSource = depth === maxSpreadDistance;
    
    const hasFluidAbove = b.above()?.typeId === b.typeId;
    let isFallingFluid = hasFluidAbove || fluidStates["lumstudio:fluidMode"] === "active";

    // Rule 1: Flowing down into air
    const belowBlock = b.below();
    if (belowBlock?.isAir) {
        const newPerm = fluidBlock.withState("lumstudio:fluidMode", "active");
        belowBlock.setPermutation(newPerm);
        if (!isSource) {
            b.setPermutation(AIR);
        }
        return;
    }

    // Rule 2: Drying up
    let canBeSustained = false;
    if (isSource) {
        canBeSustained = true;
    } else {
        for (const dir of DIRECTIONS) {
            const neighbor = b.offset(dir);
            if (neighbor?.typeId === b.typeId && neighbor.permutation.getState("lumstudio:depth") > depth) {
                canBeSustained = true;
                break;
            }
        }
        if (hasFluidAbove) canBeSustained = true;
    }

    if (!canBeSustained) {
        b.setPermutation(AIR);
        return;
    }

    // Rule 3: Spreading sideways
    if (depth > 0 && !isFallingFluid) {
        const newDepth = depth - 1;
        if (newDepth >= 0) {
            for (const dir of DIRECTIONS) {
                const neighbor = b.offset(dir);
                if (neighbor?.isAir) {
                    const perm = fluidBlock.withState("lumstudio:depth", newDepth);
                    neighbor.setPermutation(perm);
                }
            }
        }
    }

    // Final state update for visuals
    const newSlope = calculateSlope(b);
    const newFluidState = fluidState(depth / maxSpreadDistance);
    const newMode = isFallingFluid ? "active" : "dormant";
    
    const newPerm = fluidBlock.withState("fluid_state", newFluidState)
                           .withState("slope", newSlope)
                           .withState("lumstudio:fluidMode", newMode);

    if (!areEqualPermutations(b.permutation, newPerm)) {
        b.setPermutation(newPerm);
    }
}

/*========================================================================
  Fluid Queue & Event Listener Initialization
========================================================================*/

// Start the run interval for all registered fluid queues.
for (const queue of Object.values(Queues)) {
  queue.run(20); // Process 20 updates per tick for each fluid type.
}

// Register a single, global listener for all block updates.
BlockUpdate.on((update) => {
  const block = update.block;
  
  if (block && block.isValid() && Queues[block.typeId]) {
    const queue = Queues[block.typeId];
    queue.add(block);
  }
});
`);

    const BLOCKUPDATE_JS_CONTENT = JSON.stringify(`import { world, system, Block, Dimension } from "@minecraft/server";
export { BlockUpdate };

/**
 * @typedef {Object} Offset
 * @property {number} x
 * @property {number} y
 * @property {number} z
 */

const Events = {};
const Offsets = [
  { x: 0, y: 0, z: 0 }, { x: 1, y: 0, z: 0 }, { x: -1, y: 0, z: 0 },
  { x: 0, y: 1, z: 0 }, { x: 0, y: -1, z: 0 }, { x: 0, y: 0, z: 1 },
  { x: 0, y: 0, z: -1 }
];
let LastEventId = -1;

class BlockUpdate {
  constructor(data) {
    this.block = data.block;
    this.source = data.source;
  }

  static on(callback) {
    const id = ++LastEventId + "";
    Events[id] = callback;
    return id;
  }

  static off(id) {
    delete Events[id];
  }

  static trigger(source) {
    for (const offset of Offsets) {
      try {
        const block = source.offset(offset);
        if (block) BlockUpdate.triggerEvents({ block, source });
      } catch {}
    }
  }

  static triggerEvents(data) {
    const update = new BlockUpdate(data);
    Object.values(Events).forEach(callback => callback(update));
  }
}

const easyTrigger = (data) => BlockUpdate.trigger(data.block);

world.beforeEvents.playerInteractWithBlock.subscribe(data => {
  if (!data.isFirstEvent) return;
  system.run(() => {
    if (data.block.isValid && !data.cancel) BlockUpdate.trigger(data.block);
  });
});

world.afterEvents.playerBreakBlock.subscribe(easyTrigger);
world.afterEvents.buttonPush.subscribe(easyTrigger);
world.afterEvents.leverAction.subscribe(easyTrigger);
world.afterEvents.pistonActivate.subscribe(easyTrigger);
world.afterEvents.playerPlaceBlock.subscribe(easyTrigger);
world.afterEvents.pressurePlatePop.subscribe(easyTrigger);
world.afterEvents.pressurePlatePush.subscribe(easyTrigger);
world.afterEvents.tripWireTrip.subscribe(easyTrigger);
world.afterEvents.projectileHitBlock.subscribe(data => BlockUpdate.trigger(data.getBlockHit().block));

world.afterEvents.explosion.subscribe(data => {
  const triggeredBlocks = data.getImpactedBlocks().slice();
  for (const source of triggeredBlocks) {
    BlockUpdate.triggerEvents({ block: source });
    for (const offset of Offsets) {
      try {
        const neighbor = source.offset(offset);
        if (neighbor && !triggeredBlocks.includes(neighbor)) {
          triggeredBlocks.push(neighbor);
          BlockUpdate.triggerEvents({ block: neighbor, source });
        }
      } catch {}
    }
  }
});

const OriginalMethods = [
  { class: Block, name: "setType" }, { class: Block, name: "setPermutation" },
  { class: Block, name: "setWaterlogged" }, { class: Dimension, name: "setBlockType" },
  { class: Dimension, name: "setBlockPermutation" }
];

for (const data of OriginalMethods) {
  const originalMethod = data.class.prototype[data.name];
  data.class.prototype[data.name] = function(...args) {
    originalMethod.apply(this, args);
    const block = this instanceof Dimension ? this.getBlock(args[0]) : this;
    if (block) BlockUpdate.trigger(block);
  };
}
`);

    const FLUIDS_JS_CONTENT = JSON.stringify(`import { ItemStack, BlockPermutation, system, world } from "@minecraft/server";
import { AIR } from "./API";

let currentTickRunned = false;

function placeOrTakeFluid(itemStack, player, hit) {
  const fluidPlacerTag = itemStack.getTags().find(str => str.startsWith("placer:"));
  if (!hit) return;

  const { face, block } = hit;
  const targetBlock = block.relative(face);

  if (targetBlock.isAir && fluidPlacerTag) {
    const fluidTypeId = fluidPlacerTag.slice(7);
    const fluidPermutation = BlockPermutation.resolve(fluidTypeId)
      .withState("lumstudio:depth", 7)
      .withState("slope", "none")
      .withState("fluid_state", "full")
      .withState("lumstudio:fluidMode", "dormant");
    
    targetBlock.setPermutation(fluidPermutation);
    player.getComponent("equippable").setEquipment("Mainhand", new ItemStack("bucket"));
    return;
  }

  const fluidState = targetBlock.permutation.getState("fluid_state");
  if (targetBlock.hasTag("fluid") && fluidState === "full" && itemStack.typeId === "minecraft:bucket") {
    const bucketItem = new ItemStack("\`\${targetBlock.typeId}_bucket\`");
    targetBlock.setPermutation(AIR);
    player.getComponent("equippable").setEquipment("Mainhand", bucketItem);
  }
}

world.afterEvents.itemUse.subscribe(({ itemStack, source: player }) => {
  const hit = player.getBlockFromViewDirection({ includePassableBlocks: true, maxDistance: 6 });
  if (hit) placeOrTakeFluid(itemStack, player, hit);
});

world.beforeEvents.itemUseOn.subscribe(ev => {
  if (currentTickRunned) {
    ev.cancel = true;
    return;
  }
  currentTickRunned = true;
  placeOrTakeFluid(ev.itemStack, ev.source, { block: ev.block, face: ev.blockFace });
  system.run(() => { currentTickRunned = false; });
});

system.runInterval(() => {
  for (const player of world.getPlayers()) {
    const headBlock = player.getHeadLocation();
    const bodyBlock = player.location;
    const dimension = player.dimension;

    if (dimension.getBlock(headBlock)?.hasTag("fluid")) {
      player.runCommandAsync("fog @s push lumstudio:custom_fluid_fog fluid_fog");
    } else {
      player.runCommandAsync("fog @s remove fluid_fog");
    }

    const velocity = player.getVelocity();
    if (dimension.getBlock(bodyBlock)?.hasTag("fluid")) {
      if (player.isJumping) {
        player.addEffect("slow_falling", 5, { showParticles: false, amplifier: 1 });
      }
      if (velocity.y < 0.05) {
        player.applyKnockback(0, 0, 0, Math.abs(velocity.y) * 0.3 + 0.08);
      }
    }
  }
}, 2);
`);

    const QUEUE_JS_CONTENT = JSON.stringify(`import { system } from "@minecraft/server";

export class FluidQueue {
    #marked = new Set();
    #optimized = [];
    #instant = [];
    #isRunning = false;
    #runId;

    constructor(operation, blockTypeId) {
        if (typeof operation !== 'function' || operation.length !== 1) {
            throw new Error("Operation should be a function with one parameter");
        }
        this.type = blockTypeId;
        this.blockOperation = operation;
    }

    add(block) {
        if (!this.#isRunning) return;
        if (block.typeId !== this.type) return;

        if (this.#marked.has(block)) {
            this.#instant.push(block);
            this.#marked.delete(block);
            const index = this.#optimized.indexOf(block);
            if (index !== -1) this.#optimized.splice(index, 1);
        } else {
            this.#optimized.push(block);
        }
    }

    skipQueueFor(block) {
        this.#marked.add(block);
    }

    run(countPerTick) {
        this.stop();
        this.#runId = system.runInterval(() => {
            for (const block of this.#instant) {
                try { this.blockOperation(block); } catch (e) { console.error(\`FluidQueue Instant Error: \${e}\`); }
            }
            this.#instant.length = 0;

            for (let i = 0; i < countPerTick && this.#optimized.length > 0; i++) {
                const block = this.#optimized.shift();
                if (block?.typeId === this.type) {
                    try { this.blockOperation(block); } catch (e) { console.error(\`FluidQueue Ticking Error: \${e}\`); }
                }
            }
        }, 0);
        this.#isRunning = true;
    }

    stop() {
        if (this.#isRunning) {
            system.clearRun(this.#runId);
            this.#isRunning = false;
        }
    }
}
`);

    document.getElementById('fluidForm').addEventListener('submit', async function (e) {
      e.preventDefault();
      const generateButton = document.getElementById('generateButton');
      const statusMessage = document.getElementById('statusMessage');

      generateButton.disabled = true;
      statusMessage.textContent = 'Reading files...';

      const config = {
        name: document.getElementById('fluidName').value,
        id: document.getElementById('fluidID').value,
        fogColor: document.getElementById('fogColor').value,
        buoyancy: parseFloat(document.getElementById('buoyancy').value),
        damage: parseInt(document.getElementById('damage').value),
        effect: document.getElementById('effect').value,
        burnsEntities: document.getElementById('burnsEntities').checked,
        supportsBoats: document.getElementById('supportsBoats').checked,
      };
      const textureFile = document.getElementById('texture').files[0];
      const bucketTextureFile = document.getElementById('bucketTexture').files[0];

      try {
        const textureBuffer = await textureFile.arrayBuffer();
        const bucketTextureBuffer = await bucketTextureFile.arrayBuffer();
        statusMessage.textContent = 'Generating assets...';

        const zip = new JSZip();
        const safeId = config.id.replace(':', '_');
        const packName = `${config.name} Fluid Pack`;
        const packDesc = `A custom fluid pack for ${config.name}.`;

        // Generate core assets
        const geometry = generateGeometries();
        const permutations = generatePermutations();
        const blockJson = getBlockJson(config, permutations);
        const bucketJson = getBucketItemJson(config);
        const registrationScript = getRegistrationScript(config);

        // Generate manifests
        const bpManifest = getManifestJson(packName, packDesc, "data");
        const rpManifest = getManifestJson(packName, packDesc, "resources");
        
        // Add BP files
        const bp = zip.folder('BP');
        bp.file('manifest.json', JSON.stringify(bpManifest, null, 2));
        bp.folder('blocks').file(`${safeId}.json`, JSON.stringify(blockJson, null, 2));
        bp.folder('items').file(`${safeId}_bucket.json`, JSON.stringify(bucketJson, null, 2));
        
        const scriptsFolder = bp.folder('scripts');
        scriptsFolder.file('API.js', JSON.parse(API_JS_CONTENT));
        scriptsFolder.file('BlockUpdate.js', JSON.parse(BLOCKUPDATE_JS_CONTENT));
        scriptsFolder.file('fluids.js', JSON.parse(FLUIDS_JS_CONTENT));
        scriptsFolder.file('queue.js', JSON.parse(QUEUE_JS_CONTENT));
        scriptsFolder.folder('generated').file('register_fluids.js', registrationScript);

        // Add RP files
        const rp = zip.folder('RP');
        rp.file('manifest.json', JSON.stringify(rpManifest, null, 2));
        const blocksJson = { [config.id]: { "sound": "bucket.fill_lava", "textures": safeId } };
        const itemTextureJson = {
            "resource_pack_name": "vanilla", "texture_name": "atlas.items",
            "texture_data": { [`${safeId}_bucket`]: { "textures": `textures/items/${safeId}_bucket` } }
        };
        const terrainTextureJson = {
            "resource_pack_name": "vanilla", "texture_name": "atlas.terrain", "padding": 8, "num_mip_levels": 4,
            "texture_data": { [safeId]: { "textures": `textures/blocks/${safeId}` } }
        };
        rp.file('blocks.json', JSON.stringify(blocksJson, null, 2));
        rp.file('item_texture.json', JSON.stringify(itemTextureJson, null, 2));
        rp.file('terrain_texture.json', JSON.stringify(terrainTextureJson, null, 2));
        rp.folder('models').folder('blocks').file('fluid_geometry.json', JSON.stringify(geometry, null, 2));
        rp.folder('textures').folder('blocks').file(`${safeId}.png`, textureBuffer);
        rp.folder('textures').folder('items').file(`${safeId}_bucket.png`, bucketTextureBuffer);

        // Generate and trigger download
        statusMessage.textContent = 'Zipping files...';
        const blob = await zip.generateAsync({ type: 'blob' });
        const filename = `${config.name.replace(/\s/g, '_')}_Addon.mcaddon`;
        
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = URL.createObjectURL(blob);
a.download = filename;
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(a.href);
        document.body.removeChild(a);

        statusMessage.textContent = 'Generation complete! Check your downloads.';
      } catch (error) {
        console.error('Error:', error);
        statusMessage.textContent = `Error: ${error.message}`;
      } finally {
        generateButton.disabled = false;
      }
    });
  </script>
</body>
</html>
